MeshRenderer Dynamic Occluded|Enable this check box to indicate to Unity that occlusion culling should be performed for this object even if it is not marked as static.
MeshRenderer Materials|A list of Materials to render the model with.
MeshRenderer Lightmap Static|Enable this check box to indicate to Unity that the object’s location is fixed and it will participate in Global Illumination computations. If an object is not marked as Lightmap Static then it can still be lit using Light Probes.
MeshRenderer Motion Vectors|If enabled, the line has motion vectors rendered into the Camera motion vector Texture. See Renderer.motionVectorGenerationMode in the Scripting API reference documentation to learn more.
MeshRenderer Receive Shadows|Enable this check box to make the Mesh display any shadows that are cast upon it. Review Shadows is only supported when using Progressive Lightmapper
MeshRenderer Cast Shadows|On	~~~~The Mesh will cast a shadow when a shadow-casting Light shines on it~~    ~~Off	~~~~The Mesh will not cast shadows~~    ~~Two Sided	~~~~Two sided shadows are cast from either side of the Mesh. Two sided shadows are not supported by Enlighten or Progressive Lightmapper.~~~~Shadows Only	~~~~Shadows from the Mesh will be visible, but not the Mesh itself
MeshRenderer Anchor Override|A Transform used to determine the interpolation position when the Light Probe or Reflection Probe systems are used.
MeshRenderer Reflection Probes|Specifies how the object is affected by reflections in the scene. You cannot disable this property in deferred rendering modes.~~~~Off	~~~~Reflection probes are disabled, skybox will be used for reflection.~~~~Blend Probes	~~~~Reflection probes are enabled. Blending occurs only between probes, useful in indoor environments. The renderer will use default reflection if there are no reflection probes nearby, but no blending between default reflection and probe will occur.~~~~Blend Probes and Skybox~~~~Reflection probes are enabled. Blending occurs between probes or probes and default reflection, useful for outdoor environments.~~~~Simple	~~~~Reflection probes are enabled, but no blending will occur between probes when there are two overlapping volumes.
Mesh Renderer Light Probes|Probe-based lighting interpolation mode.~~~~Off~~~~The Renderer doesn’t use any interpolated Light Probes.~~~~Blend Probes	~~~~The Renderer uses one interpolated Light Probe. This is the default option.~~~~Use Proxy Volume	~~~~The Renderer uses a 3D grid of interpolated Light Probes.
Mesh Renderer|The Mesh Renderer takes the geometry from the Mesh Filter and renders it at the position defined by the object’s Transform component.
Mesh Filter|The Mesh Filter takes a mesh from your assets and passes it to the Mesh Renderer for rendering on the screen.~~~~.Mesh	~~~~Reference to a mesh that will be rendered. The Mesh is located inside your Assets Directory.~~~~When importing mesh assets, Unity automatically creates a Skinned Mesh Renderer if the mesh is skinned, or a Mesh Filter along with a Mesh Renderer, if it is not.~~~~To see the Mesh in your scene, add a Mesh Renderer to the GameObject. It should be added automatically, but you will have to manually re-add it if you remove it from your object. If the Mesh Renderer is not present, the Mesh will still exist in your scene (and computer memory) but it will not be drawn.
Object size considerations|The size of the your GameObject’s mesh is much more important than the mass of the Rigidbody. If you find that your Rigidbody is not behaving exactly how you expect - it moves slowly, floats, or doesn’t collide correctly - consider adjusting the scale of your mesh asset. Unity’s default unit scale is 1 unit = 1 meter, so the scale of your imported mesh is maintained, and applied to physics calculations. For example, a crumbling skyscraper is going to fall apart very differently than a tower made of toy blocks, so objects of different sizes should be modeled to accurate scale.~~~~If you are modeling a human make sure the model is around 2 meters tall in Unity. To check if your object has the right size compare it to the default cube. You can create a cube using GameObject > 3D Object > Cube. The cube’s height will be exactly 1 meter, so your human should be twice as tall.~~~~If you aren’t able to adjust the mesh itself, you can change the uniform scale of a particular mesh asset by selecting it in Project View and choosing Assets->Import Settings… from the menu. Here, you can change the scale and re-import your mesh.~~~~If your game requires that your GameObject needs to be instantiated at different scales, it is okay to adjust the values of your Transform’s scale axes. The downside is that the physics simulation must do more work at the time the object is instantiated, and could cause a performance drop in your game. This isn’t a terrible loss, but it is not as efficient as finalizing your scale with the other two options. Also keep in mind that non-uniform scales can create undesirable behaviors when Parenting is used. For these reasons it is always optimal to create your object at the correct scale in your modeling application.
Continuous Collision Detection|Continuous collision detection is a feature to prevent fast-moving colliders from passing each other. This may happen when using normal (Discrete) collision detection, when an object is one side of a collider in one frame, and already passed the collider in the next frame. To solve this, you can enable continuous collision detection on the rigidbody of the fast-moving object. Set the collision detection mode to Continuous to prevent the rigidbody from passing through any static (ie, non-rigidbody) MeshColliders. Set it to Continuous Dynamic to also prevent the rigidbody from passing through any other supported rigidbodies with collision detection mode set to Continuous or Continuous Dynamic. Continuous collision detection is supported for Box-, Sphere- and CapsuleColliders. Note that continuous collision detection is intended as a safety net to catch collisions in cases where objects would otherwise pass through each other, but will not deliver physically accurate collision results, so you might still consider decreasing the fixed Time step value in the TimeManager inspector to make the simulation more precise, if you run into problems with fast moving objects.
Compound Colliders|Compound Colliders are combinations of primitive Colliders, collectively acting as a single Collider. They come in handy when you have a model that would be too complex or costly in terms of performance to simulate exactly, and want to simulate the collision of the shape in an optimal way using simple approximations. To create a Compound Collider, create child objects of your colliding object, then add a Collider component to each child object. This allows you to position, rotate, and scale each Collider easily and independently of one another. You can build your compound collider out of a number of primitive colliders and/or convex mesh colliders.~~~~For example, a Gun Model GameObject has a Rigidbody attached, and multiple primitive Colliders as child GameObjects. When the Rigidbody parent is moved around by forces, the child Colliders move along with it. The primitive Colliders will collide with the environment’s Mesh Collider, and the parent Rigidbody will alter the way it moves based on forces being applied to it and how its child Colliders interact with other Colliders in the Scene.~~~~Mesh Colliders can’t normally collide with each other. If a Mesh Collider is marked as Convex, then it can collide with another Mesh Collider. The typical solution is to use primitive Colliders for any objects that move, and Mesh Colliders for static background objects.
Rigidbody Colliders|Colliders are another kind of component that must be added alongside the Rigidbody in order to allow collisions to occur. If two Rigidbodies bump into each other, the physics engine will not calculate a collision unless both objects also have a Collider attached. Collider-less Rigidbodies will simply pass through each other during physics simulation.~~~~Box Collider - primitive shape of a cube~~~~Sphere Collider - primitive shape of a sphere~~~~Capsule Collider - primitive shape of a capsule~~~~Mesh Collider - creates a collider from the object’s mesh, cannot collide with another Mesh Collider~~~~Wheel Collider - specifically for creating cars or other moving vehicles~~~~Terrain Collider - handles collision with Unity’s terrain system
Rigidbody Animation|For some situations, mainly creating ragdoll effects, it is neccessary to switch control of the object between animations and physics. For this purpose Rigidbodies can be marked isKinematic. While the Rigidbody is marked isKinematic, it will not be affected by collisions, forces, or any other part of the physics system. This means that you will have to control the object by manipulating the Transform component directly. Kinematic Rigidbodies will affect other objects, but they themselves will not be affected by physics. For example, Joints which are attached to Kinematic objects will constrain any other Rigidbodies attached to them and Kinematic Rigidbodies will affect other Rigidbodies through collisions.
To control your Rigidbodies|use scripts to add forces or torque. You do this by calling AddForce() and AddTorque() on the object’s Rigidbody. Remember that you shouldn’t be directly altering the object’s Transform when you are using physics.
the Rigidbody and the Transform of the same GameObject|Generally, you shouldnt manipulate the Rigidbody and the Transform of the same GameObject - only one or the other.~~~~The biggest difference between manipulating the Transform versus the Rigidbody is the use of forces. Rigidbodies can receive forces and torque, but Transforms cannot. Transforms can be translated and rotated, but this is not the same as using physics. You’ll notice the distinct difference when you try it for yourself. Adding forces/torque to the Rigidbody will actually change the object’s position and rotation of the Transform component. This is why you should only be using one or the other. Changing the Transform while using physics could cause problems with collisions and other calculations.
Rigidbody Constraints|Restrictions on the Rigidbody’s motion:~~~~- Freeze Position	~~~~Stops the Rigidbody moving in the world X, Y and Z axes selectively.~~~~- Freeze Rotation	~~~~Stops the Rigidbody rotating around the local X, Y and Z axes selectively.
Rigidbody Collision Detection|Used to prevent fast moving objects from passing through other objects without detecting collisions.~~~~- Discrete	Use Discrete collision detection against all other colliders in the scene. Other colliders will use Discrete collision detection when testing for collision against it. Used for normal collisions (This is the default value).~~~~- Continuous	Use Discrete collision detection against dynamic colliders (with a rigidbody) and continuous collision detection against static MeshColliders (without a rigidbody). Rigidbodies set to Continuous Dynamic will use continuous collision detection when testing for collision against this rigidbody. Other rigidbodies will use Discrete Collision detection. Used for objects which the Continuous Dynamic detection needs to collide with. (This has a big impact on physics performance, leave it set to Discrete, if you don’t have issues with collisions of fast objects)~~~~- Continuous Dynamic	Use continuous collision detection against objects set to Continuous and Continuous Dynamic Collision. It will also use continuous collision detection against static MeshColliders (without a rigidbody). For all other colliders it uses Discrete collision detection. Used for fast moving objects.
Rigidbody Interpolate|Try one of the options only if you are seeing jerkiness in your Rigidbody’s movement.~~~~~~- None	No Interpolation is applied.~~~~- Interpolate	Transform is smoothed based on the Transform of the previous frame.~~~~- Extrapolate	Transform is smoothed based on the estimated Transform of the next frame.
Rigidbody Is Kinematic|If enabled, the object will not be driven by the physics engine, and can only be manipulated by its Transform. This is useful for moving platforms or if you want to animate a Rigidbody that has a HingeJoint attached.
Rigidbody Use Gravity|If enabled, the object is affected by gravity.
Rigidbody Angular Drag|How much air resistance affects the object when rotating from torque. 0 means no air resistance. Note that you cannot make the object stop rotating just by setting its Angular Drag to infinity.
Rigidbody Drag|How much air resistance affects the object when moving from forces. 0 means no air resistance, and infinity makes the object stop moving immediately.
Rigidbody Mass|The mass of the object (in kilograms by default).
Rigidbody|Rigidbodies enable your GameObjects to act under the control of physics. The Rigidbody can receive forces and torque to make your objects move in a realistic way. Any GameObject must contain a Rigidbody to be influenced by gravity, act under added forces via scripting, or interact with other objects through the NVIDIA PhysX physics engine.
quiz.properties|name=Unity~~q_lang=en-US~~a_lang=en-US~~fontsize_q=40~~fontsize_a=34
